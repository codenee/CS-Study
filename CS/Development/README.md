# Part 1-1 Development
- [Part 1-1 Development](#part-1-1-Development)
  - [REST API](#REST-API)
  - [MVC 패턴](#MVC-Pattern)
  - [쿠키와 세션](#Cookie-vs-Session)
  - [캐시](#캐시)
  - [컴퓨터 구성 요소](#컴퓨터-구성-요소)
   

[Up](#part-1-1-Development) / [back](https://github.com/codenee/CS-Study)

</br>

# 개발 상식
## REST API
Representational State Transfer
* 분산 네트워크 상에서 자원(리소스)을 표현하고 그 상태를 전송하는 아키텍처 스타일.
* 서버 자원을 클라이언트에 구애받지 않고 사용할 수 있게 하는 설계 방식.
* 클라이언트에서 정보를 요청하면 서버는 특정 기기에 종속되지 않고 모든 기기에 통용할 수 있는 JSON데이터를 응답으로 보냅니다.
* 서버가 클라이언트의 요청에 체계적으로 대응할 수 있어서 서버 프로그램의 재사용과 확장성이 좋아집니다.

### REST
* HTTP URL로 서버의 자원을 명시하고, HTTP메서드(POST, GET, PATCH/PUT, DELETE)로 해당 자원에 대해 CRUD하는 것을 말합니다.

### API
* 클라이언트가 서버의 자원을 요청할 수 있도록 서버에서 제공하는 인터페이스입니다.

### REST API 특징
* 자원(Resources)
  * REST에서는 모든 자원을 고유한 식별자(URI)를 통해 표현.
  * 웹의 자원은 각각의 URI로 식별되며(/users), 이러한 지원은 서버에 의해 관리됨.
* 표현(Representation)
  * 자원의 상태는 다양한 표현으로 나타낼 수 있다.
  * 주로 JSON 또는 XML형식의 데이터를 사용한다.
  * 클라이언트는 이러한 표현을 통해 서버와 상호작용한다.
* 상태 전이(Stateless)
  * REST는 상태를 유지하지 않는(Stateless)특징을 가지고 있다.
  * 각 요청은 모든 필요한 정보를 포함하고 있어야 하며, 서버는 요청을 처리하기 위해 필요한 정보만을 이용.
  * 세션 상태는 서버에 저장되지 않고 클라이언트에 의해 유지되어야 한다.
* 인터페이스 일관성(Uniform Interface)
  * REST는 일관된 인터페이스를 제공.
  * 자원에 대한 표준화된 인터페이스로서, CRUD연산을 통해 자원을 조작한다.
  * 이로써 서버와 클라이언트 간의 상호 운용성을 높이게 된다.
    
</br>

위의 4가지 특징(혹은 self-descriptive, HATEOAS)을 엄격하게 지키는 API를 보고 "RESTful API" 라고 한다.

</br>

### 자원 식별
* REST API의 좋은 예와 나쁜 예

| API  | GOOD  | BAD  |
|---|---|---|
| 글 조회  | GET /post/{id}  | GET /get/posts/{id} |
| 글 생성  | POST /posts  |  POST /posts/create |
| 글 삭제  | DELETE /posts/{id}  |  DELETE /posts/delete/{id} |


### 데이터 표현
* JSON데이터는 자바스크립트 방식을 차용한 객체 표현식으로, Key와 Value쌍으로 이루어진 속성(property)로 구성된다.
* {"key" : "value"}

### 상태 전이
* REST API는 서버가 클라이언트의 상태를 저장하지 않습니다.
* HTTP 메서드를 통해 클라이언트와 서버 간의 상태 전이를 일으켜 통신을 효과적으로 할 수 있도록 합니다.

### 인터페이스 일관성
* REST API는 일관된 인터페이스를 제공하기 위해 HTTP메서드와 URI를 일관성있게 사용한다.

|Method|URI|
|---|---|
|POST| /posts|
|PATCH| /posts/{postId}|
|DELETE| /posts/{postId}|

위와 같이 게시물 생성, 수정, 삭제 URI를 일관성있게 사용합니다.

</br>

>올바르지 않는 방법
>>POST /posts/create </br>
>>PATCH /posts/update/{postId} </br>
>>이렇게 사용하면 안된다고 합니다.

</br>

[Up](#part-1-1-Development)

</br>

## MVC Pattern
* 뷰 템플릿
  * view template은 화면을 담당하는 기술로, 웹 페이지(view)를 하나의 틀(template)로 만들고 여기에 변수를 삽입해 서로 다른 페이지로 보여 줍니다.
  * 이 기술로 사용자 마다 웹 페이지를 만드는 것이 아니라 한 페이지에 변수만 바꿔서 사용자마다 화면을 보여주게 됩니다.
  * 생성 위치
    * 뷰 템플릿은 src > main > resources > templates 디렉터리에 만듭니다.
* MVC 패턴
  * Model : 데이터 관리
    * 애플리케이션이 포함해야 할 데이터가 무엇인지를 정의한다.
    * 데이터의 상태가 변경되면 모델은 이를 뷰에게 알린다(컨트롤러에게 알리기도 한다)
  * View : 화면
    * 애플리케이션에서 실제로 보이는 부분을 말한다.
    * 웹 브라우저에서 데이터를 보여주는 방식을 정의한 것
    * view에서 데이터에 따라 동적으로 화면을 다르게 보여주는 것을 뷰 템플릿이라고 한다.
    * 자바에서 사용하는 대표적인 템플릿 엔진으로 JSP, Thymleaf(타임리프), Mustache(머스테치) 등이 있다.
  * Controller : 클라이언트의 요청에 따라 서버에서 이를 처리하는 역할
    * 사용자의 액션에 응답하는 컴포넌트
    * 모델을 업데이트하고 다른 여러 액션을 수행

> 블로그 정리
>> https://code-space.tistory.com/375

</br>

[Up](#part-1-1-Development)

</br>

## Cookie vs Session
* 웹 환경에서는 클라이언트와 서버가 HTTP프로토콜을 이용해 통신합니다.
* HTTP는 아래와 같은 특징을 가지기 때문에 쿠키와 세션을 사용합니다.
### HTTP
Hyper Text Transfer Protocol
* 웹 상에서 웹 서버 및 웹 브라우저 상호 간의 데이터 전송을 위한 응용계층 프로토콜입니다.
* 요청 및 응답 메시지로 대응되는 구조로, 동작 형태가 클라이언트-서버 모델로 동작합니다.
1. Connectionless(비연결성)
* 클라이언트가 서버에 요청(Request)를 했을 때, 그 요청에 따른 응답(Response)를 보낸 후 연결을 끊는 처리방식입니다.
* HTTP1.1버전에서는 커넥션을 계속 유지하고, 요청(Request)를 재활용하는 기능이 추가되었습니다.
* HTTP Header에 Keep-alive옵션을 주어 커넥션을 재활용하게 합니다. HTTP1.1버전에선 디폴트옵션입니다.
2. Stateless프로토콜
* 커넥션을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특성이 있습니다.
* 클라이언트와 첫 번째 통신에서 데이터를 주고 받았어도, 두번째 통신에서 이전 데이터를 유지하지 않습니다.
* 정보가 유지되지 않으면, 매번 페이지를 이동할 때마다 로그인 정보가 사라져, 로그인을 다시 하거나 상품을 선택했는데 구매 페이지에서 선택한 상품의 정보가 없어지는 등의 일이 발생할 수 있습니다.
* Stateful 경우를 대처하기 위해 쿠키와 세션을 사용합니다.

### Cookie
* 쿠키는 클라이언트(로컬)에 저장되는 키와 값이 들어있는 작은 데이터 파일입니다.
* 클라이언트에 저장되어 필요 시 정보를 참조하거나 재사용할 수 있습니다.
#### 쿠키 특징
* 이름, 값, 만료일(저장기간), 경로 정보로 구성
* 클라이언트에 총 300개의 쿠키 저장
* 하나의 도메인 당 20개의 쿠키를 가짐
* 하나의 쿠키는 4KB(4096byte)까지 저장 가능
#### 쿠키 동작 순서
* 클라이언트가 페이지를 요청(사용자가 웹사이트에 접근)
* 웹 서버는 쿠키를 생성
* 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄때, 같이 클라이언트에게 돌려줌
* 넘겨받은 쿠키는 클라이언트가 가지고 있다가(로컬PC에 저장)다시 서버에 요청할 떄 요청과 함께 쿠키를 전송
* 동일 사이트 재방문 시 클라이언트의 PC에 해당 쿠키가 있는 경우, 요청 페이지와 함께 쿠키를 전송

### Session
* 일정 시간 동안 같은 사용자(브라우저)로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술입니다.
* 세션은 쿠키를 기반으로 하지만 쿠키와 다르게 서버 측에 저장하고 관리합니다.
* 서버는 세션 ID를 이용해 클라이언트를 구분하며, 웹 브라우저가 서버에 접속해 브라우저를 종료할 때까지 세션을 유지합니다.

### 세션 특징
 * 웹 서버에 웹 컨테이너 상태를 유지하기 위한 정보 저장
 * 데이터가 웹 서버에 저장됨
 * 브라우저를 닫거나(세션 연결이 끊어질 경우), 
    서버에서 세션을 삭제했을 때만 삭제가 되므로, 쿠키보다 비교적 보안이 좋다.
 * 저장 데이터에 제한이 없다.(서버 용량이 허용하는 한에서)
 * 각 클라이언트에 고유 SessionID를 부여한다. 
    SessionID로 클라이언트를 구분해 각 요구에 맞는 서비스 제공
    
### 세션 동작 순서
  * 클라이언트가 페이지에 요청
  * 서버는 접근한 클라이언트의 Request-Header필드인 Cookie를 확인하여
     클라이언트가 해당 session-id를 보냈는지 확인
  * session-id가 존재하지 않는다면 서버는 session-id를 생성해 클라이언트에게 넘김
  * 클라이언트는 서버로부터 받은 session-id를 쿠키에 저장
  * 클라이언트는 서버에 요청시 이 쿠키의 session-id 값을 같이 서버에 전달
  * 서버는 전달받은 session-id로 session에 있는 클라이언트 정보를 가지고 요청을 처리 후 응답

### 쿠키와 세션 차이
  * 사용자의 정보가 저장되는 위치로 쿠키는 클라이언트에 저장되지만 세션은 서버에 저장됩니다.
    * 쿠키 - 클라이언트
    * 세션 - 서버
  * 보안 면에서 세션이 더 우수
    * 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 Request에서 스니핑당할 우려가 있어 보안에 취약. (사용자의 주민번호 같은 민감 정보를 그대로 담아 HTTP요청 보냄 -> 이걸 스니핑 당하면 보안 취약)
    * 세션은 쿠키를 이용해 session-id만 저장하고, 서버에서 처리하기 때문에 비교적 보안성이 높다.
 * 속도 면에서 쿠키가 더 우수
   * 쿠키는 쿠키에 정보가 있기 때문에 서버에 요청 시 속도가 빠르다.
   * 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 속도가 느리다.
 
 * 라이프사이클
   * 쿠키
     * 만료기간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 정보가 유지될 수 있다.
     * 만료기간을 따로 지정해 쿠키를 삭제할 때까지 유지할 수도 있다.
   * 세션
     * 만료기간을 정할 수 있지만, 브라우저가 종료되면 만료기간에 상관없이 삭제된다.
    

## 캐시
캐시는 웹페이지 요소를 저장하기 위한 임시 저장소이고,쿠키와 세션은 정보를 저장하기 위해 사용됩니다. </br>
캐시는 웹페이지를 빠르게 랜더링할 수 있도록 도와주고, 쿠키와 세션은 사용자의 인증을 도와줍니다. </br>
- 이미지, 비디오, 오디오, css, js파일 등 데이터나 값을 미리 복사해 놓는 리소스 파일들의 임시 저장소
- 저장 공간이 작고 비용이 비싼 대신 빠른 성능을 제공
- 같은 웹 페이지에 접속할 때 사용자의 PC에서 로드하여 서버를 거치지 않아도 된다.
- 이전에 사용된 데이터가 다시 사용될 가능성이 많으면 캐시 서버에 있는 데이터를 사용
  - -> 다시 사용될 확률이 있는 데이터들이 빠르게 접근할 수 있다(페이지의 로딩 속도 빨라짐)
- 캐시 히트(hit) : 캐시를 사용할 수 있는 경우(이전에 왔던 요청이랑 같은 요청일때)
- 캐시 미스(Miss) : 캐시를 사용할 수 없는 경우(웹서버로 처음 요청했을 때)


> 블로그 정리
>> https://code-space.tistory.com/358

</br>

[Up](#part-1-1-Development)

</br>

## 컴퓨터 구성 요소
CPU, RAM, HDD, SSD, Cache Memory, Register ,NIC </br>
>주기억 장치(메인메모리) : RAM </br> 보조기억 장치 : HDD, SSD

> HDD는 자기적 방식 </br> SSD는 전기적 방식

### CPU
Central Processing Unit 중앙 처리 장치 </br>
연산 작업! </br>
컴퓨터의 뇌, 컴퓨터의 다른 부품들과 신호를 주고 받으면서 시스템 전체를 제어하는 역할 </br>
CPU는 원래 한번에 하나의 작업만 처리할 수 있다(여러 프로그램 중 1개만 처리하는 것이라는 말이 아님) </br>
CPU가 하나여도 프로그램을 여러 개를 다룰 수 있다. </br>
다만, 여러 프로그램에서 다수의 작업 요청이 들어오면 한 번에 처리하지 않고 하나씩 수행한다. </br>
CPU의 계산 속도가 워낙 빠르고 중요도에 따라 작업 순서를 정해서 처리하기 때문에 프로그램 여러 개를 실행해도 속도가 느리다는 것을 느낄 수 없다. </br>
(CPU가 많은 계산을 해야하는 그래픽 작업이나 3D고사양 게임을 하면서 동시에 다른 작업들을 하면 느려짐을 느낄 수 있다) </br>

#### 레지스터
cpu안에서 연산을 처리하기 위하여 데이터를 저장하는 공간. </br>
메모리 계층의 최상위 위치. </br>
가장 빠른 속도로 접근 가능한 메모리. </br>
데이터와 명령어를 저장하는 역할. </br>
대부분의 현대 프로세서는 메인 메모리에서 레지스터로 데이터를 옮겨와 데이터를 처리한 후 그 내용을 다시 레지스터에서 메인메모리(RAM)로 저장하는 "로드-스토어"설계를 사용 </br>

### 캐시 메모리
CPU와 별도로 있는 공간이며, 메인 메모리와 CPU간의 속도 차이를 극복하기 위한 것. </br>
저장 공간이 작고 비용이 비싼 대신 빠른 성능을 제공한다. </br>
캐시 메모리는 CPU내에서 빠르게 일을 처리하려고 자체적으로 필요한 내용들을 기억하는 역할. </br>
캐시는 반응 속도가 빠른 SRAM(Static Random Access Memory) 로, 주소가 키로 주어지면 해당 공간에 즉시 접근할 수 있다. </br>
하드웨어 설계 상 DRAM은 SRAM보다 느리다.  </br>
캐시는 블록으로 구성되어 있는데 각각의 블록은 데이터를 담고 있으며, 블록의 개수와 블록의 크기가 캐시의 크기를 결정한다.  </br>
주소가 키로 주어졌을 때 그 공간에 즉시 접근할 수 있다는 것은 캐시가 하드웨어로 구현한 해시 테이블과 같다는 의미이다. </br>
캐시가 빠른 이유는 자주 사용되는 데이터만을 담아두기도 하지만, 해시 테이블의 시간 복잡도가 O(1)정도로 빠르기 때문이기도 하다. </br>

### RAM
Random Access Memory </br>
컴퓨터의 단기 기억 장치 </br>
프로그램이 실행되려면 해당 프로그램이 복사되어 메모리에 적재되어야 한다(메모리에 적재된 프로그램을 프로세스라 한다.) </br>
Random Access 이름에 의미가 있다. </br>
RAM에 저장된 어느 데이터든 접근 시간이 동일하다. </br>
RAM은 DRAM과 SRAM이 있는데 주기억장치는 DRAM을 의미한다. </br>
RAM은 저장된 데이터를 순차적이 아닌 임의의 순서로 액세스할 수 있는 데이터 저장소이다. </br>
다른 유형의 메모리 디바이스(HDD 등)는 기계적 설계상의 제한으로 미리 정해진 순서로만 데이터를 액세스한다. </br>

- 휘발성 데이터의 특성을 가지는데 왜 사용할까? </br>
1초에 몇십억 번의 연산을 하는 CPU가 필요한 데이터를 찾기에는 하드디스크가 너무 느리기 때문이다. </br>
하드디스크에 저장된 자주 사용하는 데이터(프로그램) 등을 RAM으로 옮겨 사용한다. </br>
CPU가 데이터를 빠르게 처리하는 것을 도와주는 역할이다. </br>


#### CPU와 RAM의 관계
컴퓨터에서 프로그램을 실행하면 CPU에 필요한 데이터를 요청한다. </br>
RAM은 저장장치에서 요청받은 데이터를 불러오고 CPU는 RAM으로 부터 이를 받아 계산을 수행한다. </br>
그래서 컴퓨터가 느릴때는 CPU를 업그레이드하기 보단 RAM을 업그레이드하는 편이 나을 때가 있다. </br>
RAM을 업그레이드하면 CPU가 계산에 필요한 데이터를 얻는 속도가 빨라져서 컴퓨터의 전체적인 실행 속도가 빨라지기 때문이다. </br>


### HDD
Hard Disk Drive </br>
하드디스크는 비휘발성, 순차 접근이 가능한 컴퓨터의 보조 기억장치이다. </br>
HDD는 정보를 저장하는 플래터와 정보를 찾는 헤드로 구성되어 있다. </br>
헤드가 플래터의 정보를 읽어 컴퓨터에 전달하거나 컴퓨터가 보내는 신호를 플래터에 저장하게 된다. </br>
플래터는 자성물질로 되어있어, 내부의 작은 자석이 정렬되어 있으면 1, 정렬되어 있지 않아 자기 신호를 받을 수 없는 경우 0으로 표현한다.  </br>
그리고 헤드는 0과 1의 디지털 신호를 자기적인 방식으로 기록하거나 읽게된다. </br>

### SSD
Solid State Drive : 고체(반도체) 상태 저장소  </br>
반도체의 트랜지스터의 전기적 성질, 전류를 흐르게 하거나 차단하는 '스위치'방식을 이용한다.  </br>
전기 신호가 가해지면 SSD셀에서는 전자가 저장되고, 이를 기준으로 전류를 통제함으로써 디지털 신호를 표현한다.  </br>
이 기술은 USB으로 상용화되었는데, 대용량 USB가 SSD이다.  </br>



#### HDD의 한계와 SSD의 발전
HDD는 디스크 조각 모음을 정기적으로 해줘야한다.  </br>
정보가 여기저기 흩어져 있는 경우, 디스크를 돌리는 과정에서 시간이 불필요하게 낭비될 수 있다.  </br>
조각난 정보들을 한곳에 모아 디스크의 한쪽으로 배열하면 헤드가 정보를 찾는데 걸리는 시간을 줄일 수 있다.  </br>
SSD는 전기적인 신호를 이용해 데이터를 파악하기 때문에 디스크를 돌리거나 하는 등 번거로운 작업이 없다.  </br>
그렇기에 정보를 읽고 쓰는 속도가 HDD보다 훨씬 빠르다.  </br>
SSD의 경우 '조각 모음'을 할 필요가 없다.  </br>
분산된 파일들을 읽으려면 직접 돌려야하는 HDD와 달리, 전체 파일을 한 번에 읽을 수 있기 때문이다.  </br>
이러한 이유로, 컴퓨터 부팅 드라이브에는 SSD가 사용되고 가격이 저렴한 HDD는 보조 저장매체로 사용된다.   </br>


#### SSD와 낸드플래시
낸드플래시는 SSD에 사용되는 부품이다.  </br>
낸드플래시에 정보를 저장할 수 있는 단위를 '셀'이라고 한다.  </br>
최대한 많은 용량을 저장하기 위해서는 단위 면적당 셀을 많이 포함해야 한다.  </br>
문제는 셀을 너무 많이 직접시키면, 전기적인 간섭이 심해지고 부품의 수명이 떨어지게 된다.  </br>
이러한 문제를 해결하고자 낸드플래시는 3차원으로 구현된다.  </br>
평면 기판이 아니라 원기둥을 여러 개 세우는 방식이다.  </br> 
셀을 원기둥으로 설계.  </br>
건물을 세우듯 층을 더 올릴 수 있으면 간섭을 피하는 동시에 셀 개수도 늘릴 수 있다.  </br>
이러한 기술이 고도화되면서 SSD용량은 증가하고, 가격은 내려가게 되었다.  </br>

### NIC
network interface controller  </br>
네트워크 어댑터, 이더넷 어댑터, 이더넷 카드, ethernet controller, LAN Card 라고도 불린다.  </br>
컴퓨터를 네트워크에 연결할 수 있게 해주는 하드웨어 구성 요소이다( 네트워크 안에서 컴퓨터간 신호를 주고받는 데 쓰임)  </br>
- NIC의 기능
  - Serialization : 전기적 신호를 데이터 신호 형태로 또는 그 반대로 변환함
  - Mac Address : 받은 패킷의 도착지 주소가 자신의 MAC주소가 아니면 폐기하고, 맞으면 시스템 내부에서 처리함
  - Flow control : 데이터 유실 방지를 위하여 데이터를 받지 못할 때에는 상대방에게 통신 중지를 요청할 수 있음

> 자세한 설명
>> https://code-space.tistory.com/392


</br>

[Up](#part-1-1-Development)

</br>

    
    
<!--

**굵게**
***굵은 기울임체***
__밑줄
~~취소선
'코드 블록'

'''
여러 줄
코드 블록
'''

>블록 따옴표

>>여러줄
블록 따옴표

--!>



