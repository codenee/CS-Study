# Part 3-3 Security
- [Part 3-3 Security](#part-3-3-Security)
    - [00. 암호학](#암호학)
      - [대칭키 공개키](#대칭키-공개키)
    - [01. 시스템 보안](#시스템-보안)
      - [윈도우](#Windows)
      - [버퍼 오버플로우](#Buffer-Overflow)
    - [02. 네트워크 보안](#네트워크-보안)
    - [03. 어플리케이션 보안](#어플리케이션-보안)
    - [04. 침해사고 분석 및 대응](#침해사고-분석-및-대응)

   

[back](https://github.com/codenee/CS-Study)

</br>


## 암호학
### 대칭키 공개키
#### 대칭키
* 암복호화에 사용하는 키가 동일한 암호화 방식입니다. 
* 공개키에 비해 속도는 빠르지만 키를 교환해야 한다는 문제가 있습니다.(키 배송 문제)
* 키를 교환하는 중 키가 탈취될 수 있는 문제가 있고, 사람이 증가할 수록 전부 따로 키 교환을 해야하기 때문에 관리해야할 키의 수가 증가합니다.
* 키 배송 문제를 해결하기 위한 방법
    1. 키의 사전 공유에 의한 해결
       * 키 관리기관(TA, trusted authority)이 사전에 임의의 두 사용자(A, B)에게 비밀 경로를 통하여 임의 키를 선택하여 전달하는 방법입니다. 이 방법은 일반적으로 TA와 네트워크 상의 모든 사용자 사이에 안전한 통로가 필요하며, 사용자가 많은 경우에 TA는 물론 사용자들도 많은 키를 관리해야 하는 문제점이 있습니다. 즉, n명의 사용자가 있다면 사용자는 (n-1)가지 키를 관리해야 하며 TA는 n(n-1)/2 가지 키를 관리해야 하므로 매우 복잡하고 관리 비용이 많이 지불됩니다.
    2. 키배포 센터에 의한 해결(온라인 키 분배)
        * 암호 통신이 필요해질 때마다 통신용 키를 키배포 센터(KDC, key distribution center)라는 신뢰받는 제3자에 의뢰해서 개인과 키배포 센터 사이에만 키를 사전에 공유하는 것이다. 회사 안에 키배포 센터의 역할을 하는 컴퓨터를 저장해둔다. n명의 사원이 있다면 n개의 키를 컴퓨터 데이터베이스에 저장한다.   
    3. Diffie-Hellman키 교환에 의한 해결
       * 1976년에 공개키 암호방식을 최초로 제안한 휘트필드 디피와 마틴 헬먼이 발명한 알고리즘이다.
       * Diffie-Hellman프로토콜 방법에는 양쪽 통신 주체가 KDC없이 대칭 세션키를 생성한다.
       * 대칭키를 만들기 전에 양쪽은 두 개의 수 p와 g를 선택해야 한다. 여기서 p는 매우 큰 소수로서 300자리가 넘는 십진수(1024비트)이다.
       * "키 교환"이라는 명칭이지만 실제로 키 교환을 하는 것이 아니라 공유할 키를 계산하여 만들어 내는 것입니다.
       * 이산대수 문제를 풀기 매우 어렵다는 사실을 이용하였습니다. (이산대수 문제 : G^A mode P 에서 A를 구하는 문제)
       * ECDH : "타원 곡선상의 이산대수 문제"로 대체한 키 교환 알고리즘도 있습니다.
    4. 공개키 암호에 의한 해결
       * 암복화키가 서로 다릅니다. 수신자는 미리 "암호화키"를 송신자에게 알려줍니다. 이 "암호화키"는 도청자에게 알려져도 괜찮습니다.
       * 송신자는 "암호화키"로 암호화하여 수신자에게 보냅니다.
       * 복호화할 수 있는 것은 "복호화키"를 가진 사람(수신자)만 가능합니다.
       * 이렇게 하면 "복호화키"를 수신자에게 배송할 필요가 없습니다.

#### 공개키
* 비대칭키라고도 하며, 암복호화에 사용하는 키가 다릅니다.
* 암호화와 복호화에 수학적인 함수를 사용하므로 처리 속도가 대칭키에 비해 느립니다.
* 공개키 암호화에서는 송수신자 모두 한쌍의 key(개인키, 공개키)를 가지고 있습니다.
* 송신자도 한 쌍의 키를 가지고 있어야 하며, 수신자도 자신만의 한 쌍의 키를 가지고 있어야 한다.
* 인증, 전자서명과 대칭키 교환에 유용하게 사용되고 있습니다.

#### 비교
| 항목  | 대칭키  | 공개키  |
|---|---|---|
| 키의 상호관계  | 암호화키 = 복호화키  | 암호화키 != 복호화키  |
| 안전한 키길이  | 128bit이상  |  2048bit이상 |
| 암호화키  | 비밀  | 공개  |
| 복호화키  | 비밀  | 비밀  |
| 비밀키 전송  | 필요  | 불필요  |
| 키 개수  | N(N-1)/2  | 2N  |
| 암호화 속도  | 고속  | 저속  |
| 경제성  | 높다  | 낮다  |
| 제공 서비스  | 기밀성  | 기밀성, 부인방지, 인증  |
| 목적  | 데이터(파일)암호화  | 대칭키 교환  |
| 전자서명  | 복잡  | 간단  |
| 단점  | 키 교환 원리가 없다  | 중간자 공격에 취약  |
| 해당 알고리즘  | DES, 3DES, AES, IDEA  | RSA, ECC, DSA  |
| 기밀성  | 평문을 복잡한 형태로 변환해서 기밀서 유지  | 수학적으로 해결하기 어려운 문제를 토대로 기밀성 유지  |

[Up](#part-3-3-Security)

[back](https://github.com/codenee/CS-Study)



</br>

## 시스템 보안
### Windows
* 윈도우 인증 구성 요소
  * LSA (Local Security Authority)
    * 모든 계정의 로그인에 대한 검증 및 시스템 자원에 대한 접근 권한 검사
  * SAM (Security Account Manager)
    * 계정과 패스워드 일치하는지 확인(SAM파일에 저장된 정보로) -> 인증 확인 -> 토큰 발생
    * SAM 파일
      * 사용자 로그인 정보와 그룹 계정 및 암호화된 패스워드 정보 저장한 데이터베이스
  * SRM (Service Reference Monitor)
    * 인증된 사용자에게 SID부여
* SAM파일 접근 통제 설정
  * 패스워드를 관리하고 LSA를 통한 인증을 제공하느 ㄴ중요한 파일이므로 접근 통제 필요.
  * Administrator 및 System 그룹 이외에는 SAM파일에 대한 접근을 제한한다(불필요한 계정(Everyone) 제거)
* 윈도우 보안 식별자 (SID : Security Identifier)
  * 사용자, 그룹에게 부여되는 고유한 식별 번호(윈도우는 계정으로 식별하는 것이 아니라 SID로 식별한다)
  * SAM파일에 SID저장
* 윈도우 인증 구조
  * Challenge & Response 구조
  * 인증 암호 알고리즘
    * LM (Lan Manager) : 윈도우 2000, XP, 취약한 알고리즘
    * NTLM 해시 : LM해시 + MD4해시
    * NTLMv2 : 윈도우 비스타이후 윈도우 시스템의 기본 인증 프로토콜, 매우 복잡!, 현재도 사용, 크래킹 어렵

[Up](#part-3-3-Security)

</br>

### Buffer Overflow
* 프로세스 메모리 구조
  * Text 영역
    * 프로그램 코드와 상수가 정의되어 있고, 읽기만 가능한 메모리 영역이기 때문에 데이터를 저장하려고 하면 분할 충동을 일으켜 프로세스가 중단된다.
  * Data 영역
      * 전역 변수와 정적 변수가 저장되어 있는 영역이다.
  * Heap 영역
      * 프로그래머의 필요에 따라 동적 메모리 호출에 의해 할당되는 메모리 영역이다. (메모리 위 방향으로 커진다.)
  * Stack 영역
      * 함수 인자 값, 함수 내의 지역 변수, 함수의 반환 주소 등이 저장되는 영역으로 상위 메모리 주소에서 하위 메모리 주소로 데이터가 저장된다. (메모리 아래 방향으로 커진다.)
* 버퍼 오버플로우
  * 스택 버퍼 오버플로우
    * 스택 영역에 할당된 버퍼 크기를 초과하는 양의 데이터(실행 가능 코드)를 입력하여 복귀 주소(RET, Return Address)를 변경하고 공격자가 원하는 임의의 코드를 실행
    * 공격 절차
      1) 공격 쉘 코드를 버퍼에 저장
      2) 루트 권한으로 실행되는 프로그램의 특정 함수의 스택 반환주소 버퍼를 오버플로우시켜서 공격 셸 코드가 저장되어 있는 버퍼 주소로 덮어씌운다.
      3) 특정 함수의 호출이 완료되면 조작된 반환 주소로 셸 코드의 주소가 반환되어 셸 코드가 실행되고, 루트 권한을 획득하게 된다.
  * 힙 버퍼 오버플로우
    * 프로그램 실행 시 힙 영역에 할당된 버퍼 크기를 초과하는 양의 데이터를 입력하여 메모리의 데이터와 함수 주소 등을 변경하여 공격자가 원하는 임의의 코드를 실행    
  * 셸 코드
    * 오버 플로우가 발생하는 버퍼에 저장되는 공격자의 코드로 실행 제어를 이동시키는 코드
  * 공격 대응책
    * 프로그램 개발 시 버퍼 오버플로우에 취약하지 않은 함수를 사용하거나 입력 값에 대한 적절한 크기 검증을 통해 버퍼 오버플로우가 발생하지 않도록 한다.
    * 컴파일 시간 방어
      * 스택 가드 (Stack Guard)
        * 메모리상에서 프로그램의 복귀주소와 변수 사이에 특정 값(Canary Word)을 저장해 두었다가 그 값이 변경되었을 경우를 오버플로우를 탐지 ( 카나리 단어 기법 )
      * 스택 쉴드 (Stack Shield)
        * 함수 시작 시 복귀 주소를 Global RET라는 특수 스택에 저장해 두었다가 함수 종료 시 저장된 값과 스택의 RET값을 비교해 다를 경우 오버플로우로 가정하여 프로그램 실행을 중단시키는 기술
    * 실행 시간 방어
        * ASLR (Address Space Layout Randomization), 주소 공간의 임의 추출
          * 메모리 공격을 방어하기 위해 주소 공간 배치를 난수화하는 기법으로 실행 시마다 메모리 주소를 변경시켜 악성코드에 의한 특정주소 호출을 방지.
          * 실행 시마다 메모리 주소를 변경시켜 버퍼 오버플로우를 통한 특정 주소 호출을 차단한다.
  
</br>



[Up](#part-3-3-Security)

</br>

