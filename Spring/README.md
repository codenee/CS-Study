# Part 3-1 Spring
- [토비의 스프링1](#토비의-스프링1)
  - [디자인 패턴](#디자인-패턴)
  - [1장 오브젝트와 의존관계](#1장-오브젝트와-의존관계)
    - [객체지향 설계 원칙](#객체지향-설계-원칙)
    - [스프링의 IoC](#스프링의-IoC)


[Up](#part-3-1-Spring) / [back](https://github.com/codenee/CS-Study)

</br>

# 토비의 스프링1

## 디자인 패턴
소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 `재사용 가능한 솔루션`을 말함 </br>
디자인 패턴은 주로 객체지향 설계에 관한 것이다. </br>
패턴의 설계 구조는 대부분 2가지로 구분
* 클래스 상속
* 오브젝트 합성

패턴에서 가장 중요한 것은 각 패턴의 핵심이 담긴 목적 또는 의도 </br> 

* __템플릿 메소드 패턴 Template method pattern__ </br> 
  상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법 </br>
  변하지 않는 기능은 서브클래스에 만들어두고 자주 변경되어 확장할 기능은 서브클래스에서 만들도록 한다.</br>
  `hook(훅) 메소드` : 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만둘어둔 메소드</br>
  서브클래스에서는 추상 메서드를 구현하거나, 훅 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장한다. </br>

  슈퍼클래스에 기본적인 로직의 흐름(커넥션 가져오기, SQL생성, 실행, 반환)을 만들고 </br>
  -> 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected메소드 등으로 만든 뒤 </br>
  -> 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법 </br>

* __팩토리 메소드 패턴 Factory method pattern__ </br>
  서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것 </br> 
  객체 생성을 직접하지 않고, 하위 클래스가 어떤 객체를 생성할 지 결정하도록 위임하는 디자인 패턴 -> 즉, 오버라이드된 메서드가 객체를 반환하는 패턴 </br>

  템플릿 메소드 패턴을 활용</br>
  템플릿 메소드와 마찬가지로 상속을 통해 기능을 확장하게 하는 패턴 </br>   
  슈퍼클래스 코드에서는 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다. </br>
  이 메소드는 주로 인터페이스 타입으로 오브젝트를 리턴하므로 서브클래스에서 정확히 어떤 클래스의 오브젝트를 만들어 리턴할지는 슈퍼클래스에서는 알지 못한다. </br>

  서브클래스는 다양한 방법으로 오브젝트를 생성하는 메소드를 재정의할 수 있다.
  * 팩토리 메소드 </br> 
    서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드
  * 팩토리 메소드 패턴 </br>
    팩토리 메소드 방식을 통해 오브젝트 생성 방법을 나머지 로직 즉, 슈퍼클래스의 기본 코드에서 독립시키는 방법 </br>

* __전략 패턴 Strategy pattern__ </br>
  개방 폐쇠 원칙에 실현되게 가장 맞는 패턴  </br>
  자신의 기능 맥락(context)에서 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 다지안 패턴 </br>
  (알고리즘 : 독립적인 책임으로 분리가 가능한 기능)  </br>
     </br>

* __싱글톤 패턴 Singleton pattern__  </br>
  어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름 처럼 주로 하나만 존재하도록 강제하는 패턴</br>
  하나만 만들어지는 클래스의 오브젝트는 애플리케이션 내에서 전역적으로 접근이 가능  </br>
  단일 오브젝트만 존재해야 하고, 이를 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용  </br>
  
[Up](#part-4-1-Spring) / [back](https://github.com/codenee/CS-Study)

</br>


## 1장 오브젝트와 의존관계
* 스프링이란? </br>
  자바 엔터프라이즈 애플리케이션 개발에 사용되는 애플리케이션 프레임워크 </br>
  
* 애플리케이션 기본 틀 - 스프링 컨테이너 </br>
  스프링 컨테이너라고 불리는 스프링 런타임 엔진 제공 </br>
  설정정보를 참고해서 애플리케이션을 구성하는 오브젝트를 생성하고 관리 </br>
 </br>
 
* 스프링은 3가지 핵심 프로그래밍 모델을 지원한다
  * `IoC/DI` </br>
    Inversion of Control, Dependency Injection </br>
    오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델 </br>
  * `서비스 추상화`  </br>
    환경, 서버, 특정 기술에 종속되지 않고 이식성이 뛰어나며 유연한 애플리케이션 </br>
  * `AOP`  </br>
    Aspect-Oriented Programming, 관점 지향 프로그래밍 </br>
    애플리케이션 코드에 산재해서 나타나는 부가적인 기능을 독립적으로 모듈화하는 프로그래밍 모델   </br>
 </br>

* 스프링의 성공 요인 </br>
  견고하고 건전한 자바와 엔터프라이즈 개발의 핵심 가치에 충실했기 때문 -> 단순함, 유연성
  * 단순함 Simplicity </br>
    가장 단순한 객체지향적인 개발 모델이 POJO프로그래밍
  * 유연성 flexibility </br>
    스프링은 다른 많은 프레임워크와 편리하게 접목돼서 사용될 수 있다.  </br>
    여러 프레임워크를 함께 사용하게 해주는 접착(glue)프레임워크라고도 불린다.  </br>
 </br>

* 스프링의 가장 큰 특징
  `POJO`프로그래밍을 지향하는 것 </br>
  Plain Old Java Object : 순수 자바만을 통해서 생성한 객체 </br>
  순수 자바만을 사용하여 만든 객체이므로 특정 기술이나 환경에 종속되지 않는다. </br>
  따라서 외부 기술이나 규약의 변화에 얾매이지 않아 유연하게 변화와 확장에 대처할 수 있다 </br>
  POJO를 사용하여 비즈니스 로직을 구현하면 객체지향 설계를 제한없이 적용할 수 있으며, 코드가 단순해져 테스트와 디버깅이 쉬워진다 </br>
  </br>


[Up](#part-4-1-Spring) / [back](https://github.com/codenee/CS-Study)

</br>


### 객체지향 설계 원칙
SOLID
* SRP </br>
The Single Responsibility Principle 단일 책임 원칙 </br>
클래스(객체)는 하나의 책임(기능)만 가져야 한다.
* OCP </br>
The Open Closed Principle 개방 폐쇄 원칙 </br>
클래스나 모듈은 `확장`에는 열려있어야 하고, `변경`에는 닫혀있어야 한다. </br>
인터페이스를 사용해 확장 기능을 정의한 대부분 API는 개방 폐쇄 원칙을 따른다고 봄 </br>
인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 개방되어 있다. 반면 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄되어 있다.

* LSP </br>
The Liskov Substitution Principle 리스코프 치환 원칙
서브 타입은 언제나 부모 타입으로 교체할 수 있어야 한다. </br>
다형성을 이용하기 위한 원칙
* ISP </br>
The Interface Segregation Principle 인터페이스 분리 원칙
인터페이스의 단일 책임 </br>
인터페이스를 사용에 맞게 분리해야 한다.
* DIP </br>
The Dependency Inversion Principle 의존관계 역전 원칙 </br>
어떤 class를 참조해서 사용해야하는 상황이 생긴다면, 그 class를 직접 참조하는 것이 아니라 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조하라는 원칙


[Up](#part-4-1-Spring) / [back](https://github.com/codenee/CS-Study)

</br>

### 높은 응집도와 낮은 결합도
* 높은 응집도 (cohesion) </br>
`하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중됨` </br>
변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것 </br>
->변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다고 할 수 있음 </br>
데이터를 처리하는 기능이 여기저기 흩어져 있지 않고 한 곳에 깔끔하게 모여있다. </br>
-> 자신의 기능에 충실하도록 독립돼서 순수한 자신의 책임을 담당하는 데만 충실할 수 있다.
* 낮은 결합도 (coupling) </br>
`오브젝트 또는 모듈간의 느슨한 연결 관계` </br>
하나의 변경이 발생할 때 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태 </br>
결합도가 높아지면 변경에 따른 작업량이 많아지고, 변경으로 인해 버그가 발생할 가능성이 높아진다. </br>
구체적인 구현 클래스를 알 필요 없고 구현 방법이나 전략 등 신경 쓰지 않아도 된다. </br>
-> 낮은 결합도를 통해 관계하고 있는 클래스나 모듈에 영향을 주지 않는다.


[Up](#part-4-1-Spring) / [back](https://github.com/codenee/CS-Study)

</br>



### 제어의 역전 IOC
* 프로그램의 제어 흐름 구조가 뒤바뀌는 것 </br>
오브젝트가 자신이 사용할 오브젝트를 스스로 선택, 생성하지 않는다. </br>
또한 자신이 어떻게 만들어지고 어디서 사용되는지 알 수 없다. </br>
-> 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문! </br>
프로그램의 시작을 담당하는 main()과 같은 엔트리 포인트를 제외하면 모든 오브젝트는 위임받음 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어진다.
* 서블릿, JSP, EJB는 제어의 역전 개념이 적용됨 </br>
일반적인 자바 프로그램은 main()메소드에서 시작해서 개발자가 미리 정한 순서를 따라 오브젝트가 생성되고 실행 </br>
BUT!! </br>
서블릿의 실행을 개발자가 직접 제어할 수 있는 방법은 없다 </br>
서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메소드를 호출한다 </br>
* 템플릿 메소드 </br>
제어의 역전이라는 개념을 활용해 문제를 해결하는 디자인 패턴 </br>
슈퍼클래스의 템플릿 메소드에서 필요할 때 호출해서 사용한다. </br>
제어권을 상위 템플릿 메소드에 넘기고 자신은 필요할 때 호출되서 사용하는 것 </br>
* 프레임워크 </br>
애플리케이션 코드가 프레임워크에 의해 사용됨 </br>
프레임워크가 흐름을 주도하는 중에 개발자가 만든 코드를 사용하도록 만드는 방식 </br>
-> 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 한다. </br>
라이브러리와 다른 개념!!


[Up](#part-4-1-Spring) / [back](https://github.com/codenee/CS-Study)

</br>


### 스프링의 IoC
* 스프링의 핵심 </br>
빈 팩토리 = 애플리케이션 컨텍스트
* `bean` </br>
스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트 (오브젝트 단위의 컴포넌트) </br>
스프링이 IoC방식으로 관리하는 오브젝트, 관리되는 오브젝트 </br>
스프링이 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니다! </br>
그 중에서 `스프링이 직접 그 생성과 제어를 담당하는 오브젝트`만 빈이라고 함 </br>
* `bean factory` </br>
빈의 생성과 관계설정 같은 제어를 담당하는 IoC오브젝트 </br>
스프링의 IoC를 담당하는 핵심 컨테이너 </br>
빈을 등록, 생성, 조회, 반환 등 부가적인 빈을 관리하는 기능을 담당한다. </br>
보통은 이 빈 팩토리를 사용하지 않고 이를 확장한 애플리케이션 컨텍스트를 이용한다. </br>
BeanFactory라고 붙여쓰면 빈 팩토리가 구현하고 있는 가장 기본적인 인터페이스의 이름이 된다. </br>
이 인터페이스에 getBean()과 같은 메소드가 정의되어 있다.
  * `빈 팩토리`
  주로 빈의 생성과 제어의 관점, IoC기본 기능에 초점을 맞춤
  * `애플리케이션 컨텍스트`
    스프링이 제공하는 애플리케이션 지원 기능을 모두 포함, 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC엔진
* `애플리케이션 컨텍스트` </br>
빈 팩토리를 확장한 IoC컨테이너 </br>
빈을 등록하고 관리하는 기본적인 기능은 빈 팩토리와 동일 </br>
여기에 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다 </br>
별도의 정보를 참고해서 빈의 생성, 관계설정 등의 제어 작업을 총괄 </br>
  * `ApplicationContext` </br>
    애플리케이션 컨텍스트가 구현해야 하는 기본 인터페이스 </br>
    ApplicationContext는 BeanFactory를 상속한다.

* `Configuration`, `Metadata` </br>
설정 정보, 메타정보 </br>
  * 스프링의 설정 정보 </br>
  애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보 </br>
  IoC컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용 </br>
* `컨테이너` 또는 `IoC컨테이너` </br>
  IoC방식으로 빈을 관리한다는 의미 </br>
  컨테이너, 스프링 컨테이너 = 애플리케이션 컨텍스트를 가리키는 것 </br>
* `스프링 프레임워크` </br>
  IoC컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말할 때 주로 사용

### 애플리케이션 컨텍스트
스프링의 빈 팩토리가 사용할 수 있는 본격적인 설정정보를 만들기 </br>
* `@Configuration` </br>
스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식하게 함 </br>
* `@Bean` </br>
오브젝트를 만들어주는 어노테이션 </br>
-> @Configuration이 붙은 자바 코드를 설정정보로 사용하려면 `AnnotationConfiguApplicationContext`를 이용하면 된다. </br>
ApplicationContext의 `getBean()`이라는 메소드를 이용해 오브젝트를 가져올 수 있다.
> 하나의 @Bean을 통해 얻을 수 있는 빈의 DI정보
> * 빈의 이름
> * 빈의 클래스
> * 빈의 의존 오브젝트

* 애플리케이션 컨텍스트의 동작 방식 </br>
팩토리 클래스를 설정정보로 등록해두고 </br>
@Bean이 붙은 메소드의 이름을 가져와 빈 목록을 만든다. </br>
클라이언트가 애플리케이션 컨텍스트의 getBean()메소드를 호출하면 </br>
자신의 빈 목록에서 요청한 이름이 있는지 찾고 </br>
있다면 빈을 생성하는 메소드를 호출해서 오브젝트를 생성시킨 후 </br>
클라이언트에 돌려준다 </br>

* 애플리케이션 컨텍스트의 장점
  * 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다. </br>
    > 애플리케이션 컨텍스트를 이용해 일관된 방식으로 오브젝트를 가져올 수 있음 </br>
  * 애플리케이션 컨텍스트는 종합 IoC서비스를 제공해준다. </br>
    > 오브젝트 생성과 다른 오브젝트와의 관계설정 뿐만 아니라 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수 있고, 자동 생성, 오브젝트에 대한 후처리, 등 오브젝트를 효과적으로 활용할 수 있다는 다양한 기능 제공
  * 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다. </br>
    > 애플리케이션 컨텍스트의 getBean()메소드는 빈의 이름을 이용해 빈을 찾아준다. </br>


[Up](#part-4-1-Spring) / [back](https://github.com/codenee/CS-Study)

</br>

















