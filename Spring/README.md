# Part 4-1 Spring
- [Part 4-1 Spring](#part-4-1-Spring)
  - [토비의 스프링1](#토비의-스프링1)
    - [디자인 패턴](#디자인-패턴)
    - [1장 오브젝트와 의존관계](#1장-오브젝트와-의존관계)


[Up](#part-4-1-Spring) / [back](https://github.com/codenee/CS-Study)

</br>

# 토비의 스프링1

## 디자인 패턴
소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 `재사용 가능한 솔루션`을 말함 </br>
디자인 패턴은 주로 객체지향 설계에 관한 것이다. </br>
패턴의 설계 구조는 대부분 2가지로 구분
* 클래스 상속
* 오브젝트 합성

패턴에서 가장 중요한 것은 각 패턴의 핵심이 담긴 목적 또는 의도 </br> 

* __템플릿 메소드 패턴 Template method pattern__ </br> 
  상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법 </br>
  변하지 않는 기능은 서브클래스에 만들어두고 자주 변경되어 확장할 기능은 서브클래스에서 만들도록 한다.</br>
  `hook(훅) 메소드` : 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만둘어둔 메소드</br>
  서브클래스에서는 추상 메서드를 구현하거나, 훅 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장한다. </br>

  슈퍼클래스에 기본적인 로직의 흐름(커넥션 가져오기, SQL생성, 실행, 반환)을 만들고 </br>
  -> 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected메소드 등으로 만든 뒤 </br>
  -> 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법 </br>

* __팩토리 메소드 패턴 Factory method pattern__ </br>
  서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것 </br> 
  객체 생성을 직접하지 않고, 하위 클래스가 어떤 객체를 생성할 지 결정하도록 위임하는 디자인 패턴 -> 즉, 오버라이드된 메서드가 객체를 반환하는 패턴 </br>

  템플릿 메소드 패턴을 활용</br>
  템플릿 메소드와 마찬가지로 상속을 통해 기능을 확장하게 하는 패턴 </br>   
  슈퍼클래스 코드에서는 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다. </br>
  이 메소드는 주로 인터페이스 타입으로 오브젝트를 리턴하므로 서브클래스에서 정확히 어떤 클래스의 오브젝트를 만들어 리턴할지는 슈퍼클래스에서는 알지 못한다. </br>

  서브클래스는 다양한 방법으로 오브젝트를 생성하는 메소드를 재정의할 수 있다.
  * 팩토리 메소드 </br> 
    서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드
  * 팩토리 메소드 패턴 </br>
    팩토리 메소드 방식을 통해 오브젝트 생성 방법을 나머지 로직 즉, 슈퍼클래스의 기본 코드에서 독립시키는 방법 </br>

* __전략 패턴 Strategy pattern__ </br>
  개방 폐쇠 원칙에 실현되게 가장 맞는 패턴  </br>
  자신의 기능 맥락(context)에서 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 다지안 패턴 </br>
  (알고리즘 : 독립적인 책임으로 분리가 가능한 기능)  </br>
     </br>

* __싱글톤 패턴 Singleton pattern__  </br>
  어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름 처럼 주로 하나만 존재하도록 강제하는 패턴</br>
  하나만 만들어지는 클래스의 오브젝트는 애플리케이션 내에서 전역적으로 접근이 가능  </br>
  단일 오브젝트만 존재해야 하고, 이를 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용  </br>
  
[Up](#part-4-1-Spring) / [back](https://github.com/codenee/CS-Study)

</br>


## 1장 오브젝트와 의존관계
* 스프링이란? </br>
  자바 엔터프라이즈 애플리케이션 개발에 사용되는 애플리케이션 프레임워크 </br>
  
* 애플리케이션 기본 틀 - 스프링 컨테이너 </br>
  스프링 컨테이너라고 불리는 스프링 런타임 엔진 제공 </br>
  설정정보를 참고해서 애플리케이션을 구성하는 오브젝트를 생성하고 관리 </br>
 </br>
 
* 스프링은 3가지 핵심 프로그래밍 모델을 지원한다
  * `IoC/DI` </br>
    Inversion of Control, Dependency Injection </br>
    오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델 </br>
  * `서비스 추상화`  </br>
    환경, 서버, 특정 기술에 종속되지 않고 이식성이 뛰어나며 유연한 애플리케이션 </br>
  * `AOP`  </br>
    Aspect-Oriented Programming, 관점 지향 프로그래밍 </br>
    애플리케이션 코드에 산재해서 나타나는 부가적인 기능을 독립적으로 모듈화하는 프로그래밍 모델   </br>
 </br>

* 스프링의 성공 요인 </br>
  견고하고 건전한 자바와 엔터프라이즈 개발의 핵심 가치에 충실했기 때문 -> 단순함, 유연성
  * 단순함 Simplicity </br>
    가장 단순한 객체지향적인 개발 모델이 POJO프로그래밍
  * 유연성 flexibility </br>
    스프링은 다른 많은 프레임워크와 편리하게 접목돼서 사용될 수 있다.  </br>
    여러 프레임워크를 함께 사용하게 해주는 접착(glue)프레임워크라고도 불린다.  </br>
 </br>

* 스프링의 가장 큰 특징
  `POJO`프로그래밍을 지향하는 것 </br>
  Plain Old Java Object : 순수 자바만을 통해서 생성한 객체 </br>
  순수 자바만을 사용하여 만든 객체이므로 특정 기술이나 환경에 종속되지 않는다. </br>
  따라서 외부 기술이나 규약의 변화에 얾매이지 않아 유연하게 변화와 확장에 대처할 수 있다 </br>
  POJO를 사용하여 비즈니스 로직을 구현하면 객체지향 설계를 제한없이 적용할 수 있으며, 코드가 단순해져 테스트와 디버깅이 쉬워진다 </br>
  </br>

  


[Up](#part-4-1-Spring) / [back](https://github.com/codenee/CS-Study)

</br>
