# Part 2-2-1 자바의 신

- [문제 풀이](#문제-풀이)
    - [Chapter 01 Programming](#Chapter-01-Programming)
    - [Chapter 02 Hello God of Java](#Chapter-02-Hello-God-of-Java)
    - [Chapter 03 Object](#Chapter-03-Object)
    - [Chapter 04 type](#Chapter-04-type)
    - [Chapter 05 operator](#Chapter-05-operator)
    - [Chapter 06 condition](#Chapter-06-condition)
    - [Chapter 07 Array](#Chapter-06-Array)
    - [Chapter 08 reference type](#Chapter-06-reference-type)
    - [Chapter 09 package](#Chapter-06-package)
    - [Chapter 10 inheritance](#Chapter-06-inheritance)
 
      
</br>

 [back](https://github.com/codenee/CS-Study/tree/main/Language/Java)

</br>

# 자바의 신
## 문제 풀이
### Chapter 01 Programming
1. 클래스가 뭔가요?
   - 클래스는 각각의 객체들을 나타내는 청사진(blueprint)와 같다. 즉,하나의 객체를 나타내기 위한 자바에서 가장 작은 단위로 볼 수 있으며, 상태와 행동을 갖고 있는 것을 의미한다.
2. 메소드가 뭔가요?
   - 메소드는 클래스의 "행동"을 제공하는 역할을 수행한다.
3. 메소드의 매개변수는 어디에 적어주나요?
   - 메소드의 매개변수는 메소드 선언시 사용하는 소괄호 안에 타입과 변수명 순으로 선언한다. 두 개 이상의 매개변수가 있을 경우에는 콤마로 구분한다.
4. 메소드 이름 앞에 꼭 적어 줘야 하는 건 뭐죠?
   - 메소드 이름 앞에는 반드시 리턴 타입을 선언해야만 한다.
5. 클래스가 갖고 있어야 한다고 한 두 가지가 뭐죠?
   - 상태(state)와 행동(behavior)
6. 메소드에서 결과를 돌려주려면 어떤 예약어를 사용해야 하나요?
   - return 이라는 예약어를 사용하여 결과를 돌려준다는 것을 명시한다.


[Up](#part-2-2-1-자바의-신) / [back](https://github.com/codenee/CS-Study/tree/main/Language/Java)

### Chapter 02 Hello God of Java
1. main() 메소드의 메소드 이름 앞에는 어떤 예약어들이 들어 가나요? (순서대로 쓰세요)
   - public static void
   - public : 어떤 클래스에서도 접근 가능하며
   - static : static 메소드이며 (객체를 생성하지 않아도 접근 가능한 메소드이며 "C.1"장에서 자세히 살펴본다.)
   - void : 리턴 값이 없음을 의미한다. 
2. main() 메소드의 매개변수에는 어떤 값이 들어가나요?
   - String args[] 즉, String문자열의 배열이 들어간다.
3. 만약 여러분들이 만든 클래스에 main() 메소드가 없다면, java 명령어로 그 클래스를 수행할 수 있나요?
   -  public static void main(String args[]) 로 선언되어 있는 메소드가 클래스에 없으면, 해당 클래스를 실행할 수는 없다.
4. System.out.println() 메소드는 어떤 용도로 사용하나요?
   - System.out.println() 메소드는 자바를 실행한 창에서 문자열을 출력하는데 사용된다.
5. System.out.print() 메소드는 System.out.println() 메소드와 어떤 차이가 있나요?
   - System.out.print() 메소드는 줄바꿈을 하지 않기 때문에, 이 메소드 호출 후에 출력 메소드를 호출하면 같은 줄에 결과가 출력된다.
   - 하지만, System.out.println() 메소드는 내용을 출력한 다음에 줄바꿈을 한다.
6. // 는 무엇을 하는데 사용하는 기호인가요?
   - 한 줄 주석을 의미한다. 따라서, 해당 코드의 // 뒤에 있는 모든 내용은 무시된다.
7. /* 로 시작하고, */로 끝나는 사이에 있는 소스들을 어떻게 되나요?
   - /*으로 시작하여 */으로 끝나는 주석은 블록 주석으로, 해당 블록 내의 모든 내용은 무시된다.
8. 메소드를 선언할 때 반드시 꼭 있어야 하는 세가지는 무엇인가요?
   - 메소드에는 반드시 "리턴 타입", "메소드 이름", "메소드 내용"이 있어야만 한다.

[Up](#part-2-2-1-자바의-신) / [back](https://github.com/codenee/CS-Study/tree/main/Language/Java)


### Chapter 03 Object
1. 클래스와 객체의 차이점을 말해 주세요.
   - 클래스를 통해서 객체를 생성할 수 있다.
   - 즉, 하나의 클래스를 만들면 그 클래스의 모습을 갖는 여러 객체들을 생성 할 수 있다.
   - 그러므로, 일반적인 경우 클래스의 메소드나 변수들을 사용하려면 객체를 생성하여 사용하여야 한다.
2. 객체를 생성하기 위해서 꼭 사용해야 하는 예약어는 뭐라고 했죠?
   - new 키워드를 사용하여 클래스의 객체를 생성한다.
3. 객체를 생성하기 위해서 사용하는 메소드 같이 생긴 클래스 이름에 소괄호가 있는 것을 뭐라고 하나요?
   - 생성자(Constructor)를 통하여 클래스의 객체를 생성한다.
4. 객체의 메소드를 사용하려면 어떤 기호를 객체이름과 메소드 이름 사이에 넣어주어야 하나요?
   - 클래스의 변수나 메소드를 호출하려면 "객체이름.변수", "객체이름.메소드이름()"와 같이 사용하면 된다.
5. 여러분들이 메소드를 사용하기 위해서는 어떤 것을 만들어야 하나요?
   - 클래스의 "객체"를 생성해야만 메소드를 사용할 수 있다.
6. 위의 문제에서 만들어야 하는 것은 어떤 예약어를 사용하고, 클래스의 무엇을 사용해야 하나요?
   - 객체를 생성해야 하고, new 키워드를 사용하여 생성자를 호출해야만 된다.


[Up](#part-2-2-1-자바의-신) / [back](https://github.com/codenee/CS-Study/tree/main/Language/Java)

### Chapter 04 type
1. 네가지 종류 변수는 어떻게 구분할 수 있나요?
   - 변수의 종료는 변수를 선언한 위치와 static 선언 여부에 따라 달라진다.
   - 지역 변수
     - 중괄호 내에서 선언된 변수
     - 지역 변수를 선언한 중괄호 내에서만 유효하다
   - 매개 변수
     - 메소드에 넘겨주는 변수
     - 메소드가 호출될 때 생명이 시작되고, 메소드가 끝나면 소멸된다
   - 인스턴스 변수
     - 메소드 밖에, 클래스 안에 선언된 변수, 앞에는 static이라는 예약어가 없어야 한다
     - 객체가 생성될 때 생명이 시작되고, 그 객체를 참조하고 있는 다른 객체가 없으면 소멸된다
   - 클래스 변수
     - 인스턴스 변수처럼 메소드 밖에, 클래스 안에 선언된 변수 중에서 타입 선언 앞에 static이라는 예약어가 있는 변수
     - 클래스가 처음 호출될 때 생명이 시작되고, 자바 프로그램이 끝날 때 소멸된다
2. 일반 변수의 이름을 지을 때 대문자로 시작하는 것은 일반적인 명명규칙이다.
   - 아니요
   - 첫 문자는 소문자로 시작하는 단어이고, 두 번째 단어의 첫 문자만 대문자로 시작하면 된다.
3. 자료형에는 기본 자료형과 어떤 자료형이 있나요?
   - 참조 자료형
4. 기본 자료형에는 몇가지가 있나요?
   - 8가지
5. 기본 자료형 중 정수형에는 어떤 것들이 있나요?
   - byte, short, int, long, char
6. byte는 몇 비트(bit)로 되어 있나요?
   - 8비트
7. byte 타입은 왜 만들었을까요?
   - 적은 공간에 많은 내용을 저장할 수 있다.
   - 동영상을 저장하고, 이미지를 저장할 때 저장 데이터가 모두 int타입일 경우, 단순히 숫자 하나를 표현하기 위해서 32개의 0과 1을 표시하기 위한 공간이 필요하다. 즉, byte대비 4배의 저장공간이 더 필요하게 된다는 것이다.
   - 그래서 많은 데이터를 저장할 때 byte값들을 조합해서 사용한다.
8. int와 long중 어떤 타입이 더 큰 숫자를 처리할 수 있나요?
   - long
   - long : 8바이트(64비트)
   - int : 4바이트(32비트)
9. 소수점을 처리하는 타입은 어떤 것이 있나요?
   - float, double
   - float : 4바이트(32비트) -> 부호(1자리) + 지수(8자리) + 가수(23자리)
   - double : 8바이트(64비트) -> 부호(1자리) + 지수(11자리) + 가수(52자리)
   - 돈 계산과 같이 중요한 부분에서는 이 타입들을 사용해서는 안된다. 왜냐하면 float과 double은 32비트와 64비트로 제공할 수 있는 범위를 넘어서면 그 값의 정확성을 보장하지 못하기 때문이다.
   - 그래서 자바에서는 정확한 계산이 요구될 때는 "java.math.BigDecimal" 이라는 클래스를 사용해야만 한다.
10. char는 정수형인가요?
    - 예
    - 2바이트(16비트)로, 부호가 없는(unsigned) 타입이다.
11. a라는 값을 char로 정의할 때 어떤 기호로 감싸주어야 하나요? (기호를 입력하세요)
    - '' (홑따옴표)
12. true와 false 두개의 값만을 가지는 타입은 어떤 것인가요?
    - boolean

[Up](#part-2-2-1-자바의-신) / [back](https://github.com/codenee/CS-Study/tree/main/Language/Java)


### Chapter 05 operator
1. 값을 할당할 때 사용하는 연산자의 기호는 무엇인가요?
    - 할당 연산자는 = 이며, 우측에는 할당할 값, 좌측에는 할당 받을 변수를 위치시켜야 한다.
2. 기본적인 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지를 계산할 때 사용하는 연산자의 기호는 순서대로 각각 무엇인가요?
    - 사칙연산 연산자는 + - * / 이며, 나머지는 % 연산자를 사용하면 된다.
3. += 는 무엇을 할 때 사용하는 연산자 인가요?
    - += 는 기존 값에 우측 항의 값을 더할 때 사용한다.
4. 연산의 순서를 모르거나 확실히 하고 싶을 때에는 어떤 기호를 사용해야 하나요?
    - 연산할 때 연산자의 우선순위가 혼동될 경우에는 소괄호()를 사용하면 계산의 가독성을 높일 수 있다.
5. ==와 !=의 차이는 무엇인가요?
    - == 는 값이 동등한지를, !=는 값이 다른지를 확인하는 연산자이다. 두 연산의 결과는 모두 boolean 타입이다.
6. <와 <=의 차이는 무엇인가요?
    - 두 연산자의 차이는 우측항의 값이 포함되는지 여부이다. =이 있는 연산자는 우측항의 값을 포함한다.
7. ! 연산자는 어떤 타입에 사용 할 수 있나요?
    - ! 연산자는 무조건 boolean 타입에만 사용할 수 있다. 해당 결과의 반대로 변환한다. (true일 때에는 false로, false일 때에는 true로 변환한다.)
8. ? : 로 표시하는 삼항 연산자의 ?와 : 뒤에 명시해 주는 값은 무엇을 의미 하나요?
    - "? :"연산자는 값을 간편하게 할당할 때 사용한다. 조건이 true일 경우에는 ? 뒤의 값을, false일 경우에는 : 뒤의 값을 지정한다.
9. 자바는 형변환을 한다고 했는데, short의 값을 long에 할당할 때에는 어떤 것을 해 주어야 하나요?
    - short 타입을 long 타입으로 변환할 때에는 casting을 해 줄 필요가 없다.
10. 반대로 long값을 short에 할당할 때에는 어떤 것을 해 주어야 하나요?
    - long 타입을 short 타입으로 변환할 때에는 범위가 큰 타입에서 작은 타입으로 변환되는 것이기 때문에 casting을 해 줘야만 한다.
11. 위의 두 문제에서 어떤 경우가 기존 값이 사라지고, 엉뚱한 값으로 바뀔 수 있나요?
    - 범위가 큰 타입으로 작은 타입으로 변환할 경우에는 값이 달라질 확률이 매우 높다.


[Up](#part-2-2-1-자바의-신) / [back](https://github.com/codenee/CS-Study/tree/main/Language/Java)

### Chapter 06 condition
1. if 문장의 소괄호 안에는 어떤 타입의 결과가 제공되어야 하나요?
   -  if 소괄호 안에는 boolean 타입의 결과만 올 수 있다.
2. if 조건에 맞지 않는 모든 경우를 처리할 때 사용하는 예약어는 뭔가요?
   - 모든 if 조건을 통과할 경우를 처리할 필요가 있으면 "else"라는 예약어를 사용하면 된다.
3. switch를 사용할 수 있는 기본 자료형의 타입에는 어떤 것들이 있나요?
   - long을 제외한 정수 및 Enum을 switch에서 사용할 수 있다. JDK 7 부터는 String도 사용 가능하다.
4. switch블록 안에서 비교 대상값 앞에 사용하는 예약어는 무엇인가요?
   - switch문에서 각 경우에 대해서 처리할 경우에는 "case"를 사용한다.
5. switch 조건을 빠져나가도록 하는 예약어는 무엇인가요?
   - "break"를 사용하면 대부분의 중괄호로 묶여 있는 문장을 빠져 나간다.
6. switch 조건들에 맞지 않을 때 기본 처리를 하기 위한 예약어는 무엇인가요?
   - switch 의 기본 값은 "default"를 사용한다.
7. while 문의 소괄호 안에는 어떤 형태의 결과가 제공되어야 하나요?
   - if와 마찬가지로 while문의 소괄호에는 boolean 타입의 결과가 위치해야 한다.
8. while 문을 무조건 한번은 실행하게 하려면 어떻게 해야 하나요?
   - while문은 조건이 맞지 않으면 한번도 실행하지 않지만, do-while문은 무조건 한번은 실행된다.
9. while문을 마음대로 빠져나가게 하려면 어떤 예약어를 사용하면 되나요?
   - while문을 빠져 나가기 위해서는 "break"를 사용하면 된다.
10. while문의 중간에 while문의 소괄호 점검 구문으로 건너뛰도록 할 때 사용하는 예약어는 무엇인가요?
    -
    - "continue"라는 예약어를 사용하면 while문의 조건 확인 부분으로 돌아간다.
11. for루프의 소괄호안의 가장 첫 구문(첫 세미 콜론 앞의 문장)은 for루프가 수행되는 동안 몇 번 수행되나요?
    - for루프의 세미콜론 구문 중 가장 앞에 있는 구문은 오직 한번만 수행된다.
12. for루프의 소괄호 안의 중간에 있는 구문은 어떤 타입의 결과가 제공되어야 하나요?
    - for루프의 세미콜론 구문 중 중간에 있는 구문은 boolean 타입의 값이 제공되어야만 한다.
13. for루프의 소괄호 안의 마지막에 있는 구문에서는 어떤 작업을 수행하나요?
    - for루프의 세미콜론 구문 중 가장 마지막에 있는 구문은 값을 증가하거나 감소하는 등의 반복적인 작업을 수행한다. 


[Up](#part-2-2-1-자바의-신) / [back](https://github.com/codenee/CS-Study/tree/main/Language/Java)

### Chapter 07 Array
1. 배열을 선언할 때에는 대괄호 [ ] 를 사용해야 한다.
2. 배열의 위치는 0부터 시작한다.
3. 숫자 배열의 초기 값은 0, boolean 배열의 초기 값은 false이다.
4. ArrayIndexOutOfBoundsException 은 배열의 범위를 벗어난 위치를 참조하려고 할 때 발생한다. 즉, 10자리 배열에 12번째 위치를 참조하려는 경우에 발생한다.
5. 중괄호를 이용하여 배열을 선언할 때, 중괄호를 닫은 다음에 반드시 세미콜론 ; 을 입력해야만 한다.
6. 2차원 배열을 지정할 때에는 대괄호를 2개 지정한다.
7. 배열을 처리하는 for 루프는 다음과 같이 사용할 수 있다. int[] a;로 선언되어 있는 배열은, for(int data:a) { ... }와 같이 콜론을 사용하여 사용 가능하다.
8. main() 메소드의 String args[] 라는 매개변수는 java명령 실행시 클래스 이름 뒤에 나열된 값을 취한다.예를 들어 ArrayTest라는 클래스가 시작하면서 값을 전달하려면java ArrayTest a b c와 같이 사용 가능하며, ArrayTest클래스의 main() 메소드의 매개변수인 args[] 배열의 0,1,2 위치에 있는 배열은 각각 a,b,c의 값이 할당된다.9. 8번 문제의 답에서 이야기한 대로 String의 1차원 배열로 값이 전달된다.


[Up](#part-2-2-1-자바의-신) / [back](https://github.com/codenee/CS-Study/tree/main/Language/Java)


### Chapter 08 reference type
1. 생성자는 반드시 만들 필요는 없으나, 만드는 습관을 가지는 것이 좋다.
2. 기본 생성자를 만들지 않고, 매개변수가 있는 생성자만 만들었을 때, 기본 생성자를 사용하여 객체를 생성할 수는 없다. 그러면 컴파일 에러가 발생한다.
3. 생성자의 개수는 제한이 없다.
4. this라는 예약어는 해당 객체를 의미한다. 따라서, 메소드 내에서 this를 사용하면 인스턴스 변수를 의미하게 된다.
5. return 예약어를 사용하여 메소드를 호출한 문장으로 결과를 넘겨준다.
6. void 라는 예약어는 해당 메소드의 리턴 값이 없다는 것을 의미한다.
7. static 메소드는 클래스의 객체를 생성하지 않고 클래스 이름만으로 참조할 수 있다. 많이 사용하는 System.out.println()의 경우는 System클래스에 out이라는 이름으로 선언된 클래스에 static으로 선언된 println()메소드를 호출하는 것이다.
8. 메소드의 이름을 동일하게하고, 매개변수만을 다르게 하는 것은 overloading이다.
9. 모든 기본 자료형과 참조 자료형은 매개변수로 넘어갈 때 값이 넘어가는 Pass by Value이다.
10. 모든 기본 자료형과 참조 자료형은 매개변수로 넘어갈 때 값이 넘어가는 Pass by Value이다. 단, 참조 자료형 안에 있는 변수들은 매개변수로 넘어갈 때 참조가 넘어가는 Pass by Reference 이다.
11. 가변 매개변수를 지정할 때에는 "변수타입...변수명"으로 선언하면 된다. 이 선언을 할 때, 해당 변수는 매개변수 선언의 가장 마지막에 위치해야만 한다.


[Up](#part-2-2-1-자바의-신) / [back](https://github.com/codenee/CS-Study/tree/main/Language/Java)


### Chapter 09 package
1. 패키지 선언할 때 사용하는 예약어는 package 이다.
2. 패키지 선언은 소스의 가장 위에 위치해야만 한다.
3. 패키지의 이름은 java로 시작하면 안된다.
4. 중간에라도 예약어가 패키지의 이름으로 선언되어도 안된다.
5. import는 클래스 선언 전에 명시되어 있어야만 한다.
6. 같은 패키지 내의 클래스와 java.lang 패키지에 있는 클래스는 별도로 import할 필요가 없다.
7. (별)* 기호를 사용하면 해당 패키지에 있는 모든 클래스를 import한다. 예를 들어 java.util패키지에 있는 모든 클래스를 import하려면import java.util.*;로 선언하면 된다. 하지만, 이렇게 사용할 경우 import되는 클래스 이름들이 중복될 수 있으므로, 되도록이면 명시적으로 지정하는 것이 좋다.
8. import static 을 사용하면 static한 변수를 쉽게 import할 수 있다.
9. public 접근 제어자의 범위가 가장 넓으며, 어떤 클래스에서도 해당 클래스나 변수, 메소드에 접근 가능하다.
10. private로 선언할 경우에는 해당 클래스에서만 접근 가능하다.
11. protected로 선언한 경우에는 상속받은 클래스만 접근 가능하다.
12. 자바 소스에는 파일명과 동일한 public으로 선언한 클래스가 존재해야만 한다.


[Up](#part-2-2-1-자바의-신) / [back](https://github.com/codenee/CS-Study/tree/main/Language/Java)


### Chapter 10 inheritance
1. 어떤 클래스를 상속을 받아 확장할 때에는 extends라는 예약어를 사용한다.
2. 확장을 한 클래스가 생성자를 호출하면, 자동으로 부모 클래스의 "기본 생성자"가 호출된다.
3. super라는 예약어를 사용하면 부모 클래스를 의미한다. 이 super를 메소드처럼 super()로 사용하면 부모 클래스의 생성자를 호출한다.
4. Overriding은 자식 클래스에서 부모 클래스에 선언된 메소드의 선언 구문을 동일하게 선언하여 사용하는 것을 의미한다.즉, public void printName()이라는 메소드가 부모클래스에 있고, 자식 클래스에도 동일한 메소드를 선언한다는 것이다.혼동되기 쉬운 Overloading은 상속관계와 거의 상관 없이 메소드의 이름을 동일하게 하고, 매개변수만 다르게 하는 것을 의미한다.
5. "부모 변수명=new 자식();" 과 같이 선언하는 것은 가능하다. 하지만 "자식 변수명=new 부모();"와 같이 선언하는 것은 불가능하다. 왜냐하면 자식 클래스는 부모 클래스의 모든 내용을 상속 받으므로 전자와 같이 사용하는 것이 가능하지만,후자의 경우와 같이 부모는 자식이 갖고 있는 모든 것을 갖지 못하기 때문에 불가능하다.
6. 실행시 형변환 관련 예외가 발생하지 않도록 하려면 "instanceof"예약어를 사용하여 검증 작업을 해야만 한다.
7. instanceof의 좌측에는 확인하고자 하는 변수를, 우측에는 클래스 이름이 위치한다.
8. instanceof 예약어를 통해 검증한 결과는 boolean 타입으로 제공된다.
9. Polymorphism은 다형성을 의미한다. 자식 클래스는 자신만의 "행위"를 가질 수 있지만, 부모 클래스에 선언된 메소드들도 공유 가능하다는 것을 의미한다. 다시 말해, 부모 클래스의 타입으로 변수를 선언하고, 자식 클래스의 생성자를 사용할 경우 overriding된 메소드를 호출하면 자식 클래스에 선언된 메소드가 호출되고, 부모 클래스의 메소드도 공유 가능하다는 것을 의미한다.

[Up](#part-2-2-1-자바의-신) / [back](https://github.com/codenee/CS-Study/tree/main/Language/Java)

<!--

### Chapter 
1. 
   - 
2. 
   - 
3. 
   - 
4. 
   - 
5. 
   - 
6. 
   - 


[Up](#part-2-2-1-자바의-신) / [back](https://github.com/codenee/CS-Study/tree/main/Language/Java)

-->
